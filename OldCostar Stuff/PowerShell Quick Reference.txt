POWERSHELL QUICK REFERENCE

[GETTING HELP]
get-command will list all cmdlets

[Profile and module paths]

test-path $profile
New-Item -path $profile -type file -force	# create new profile


You can have four different profiles in Windows PowerShell. The profiles are listed in load order. The most specific profiles have precedence over less specific profiles where they apply.

    * %windir%\system32\WindowsPowerShell\v1.0\profile.ps1
		This profile applies to all users and all shells.

    * %windir%\system32\WindowsPowerShell\v1.0\ Microsoft.PowerShell_profile.ps1
		This profile applies to all users, but only to the Microsoft.PowerShell shell.

    * %UserProfile%\My Documents\WindowsPowerShell\profile.ps1
		This profile applies only to the current user, but affects all shells.

    * %UserProfile%\My Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
		This profile applies only to the current user and the Microsoft.PowerShell shell.


Background information: Modules go in SubFolders in $env:PSModulePath

Installing a module means putting the main module file (the .psd1, .psm1, or .dll) into a folder in your PSModulePath.

The key thing you need to understand about PowerShell modules is how PowerShell finds them.

   1. There is an Environment variable PSModulePath which is just like the PATH variable, except for modules. By default it specifies two folders:
         1. A folder in your documents folder ( WindowsPowerShell\Modules ) which does not exist by default, and is for modules that only a single user needs, or for which each user needs their own copy
         2. The folder C:\Windows\system32\WindowsPowerShell\v1.0\Modules\ which does exist by default, and is for modules that all users on the machine need and/or modules which you want to protect from non-administrators.
   2. PowerShell searches this path in order and loads the first matching module it finds. Users can override machine modules by simply loading the same module in their profile folder.
   3. Modules are expected to be in a folder in that path. The Module should be in a folder which has the module name as its name. For example:
          * PSCX should be in the folder Modules\PSCX
          * PowerBoots should be in the folder Modules\PowerBoots
   4. There should be at least one .psd1 or .psm1 or .dll in the folder which has the same name as the folder. For example:
          * PSCX should have: Modules\PSCX\PSCX.psd1
          * PowerBoots should have Modules\PowerBoots\PowerBoots.psd1
		
[TYPES AND CLASSES]
get-process | get-member # to find the class name: System.Diagnostics.Process
# To find the static methods surround the type name with square brackets:
	[System.Diagnostics.Process] | Get-Member -static
	# GetProcesses       Method     static System.Diagnostics.Process[]...
	# overloads are shown in the definition column
# Find overloads for a given method:
	([System.Diagnostics.Process] | get-member -static GetProcesses).Definition
		# static System.Diagnostics.Process[] GetProcesses(), 
		# static System.Diagnostics.Process[] GetProcesses(String machineName)
	

[REMOTING - WINRM - CREDSSP - INVOKE-COMMAND]
# IF script lives on the remote server:
	 Invoke-Command –ComputerName 'REMOTESERVER1'
				   –ScriptBlock { &"C:\Path With Spaces\LogDeploy.ps1"
								   'C:\Path With Spaces\Log.txt'
								   'TESTWEB1' }
							   

[PROCESSES & SERVICES]
# Start a process and wait for exit
	notepad foo.txt  | out-null
# Start a process and obtain it's properties
	$arguments = 'a c:\temp\archive1.zip c:\temp\esxplot'
	$p = New-Object System.Diagnostics.Process;
	$p.StartInfo.UseShellExecute = $false;
		# Setting this property to false enables you to redirect input, output, and error streams.
	$p.StartInfo.RedirectStandardOutput = $true;
	$p.StartInfo.FileName = '\\dcfile1\users\bconrad\dev\powershell\Archive_n_Zip\7za.exe'
	$p.StartInfo.Arguments = $arguments
	[void]$p.Start();
	# $p.Id # return the process object
	$stdout = $p.StandardOutput.ReadToEnd();
	$p.WaitForExit();


# Manage processes using .Net  (Note: .Net will not allow you to kill() on remote machines :-( )
# http://msdn.microsoft.com/en-us/library/system.diagnostics.process(VS.80).aspx
[System.Diagnostics.Process]::GetProcesses("myServer") | ? {$_.name -eq "notepad" } 

# Manage proceses using WMI  (can kill remote processes)
# http://msdn.microsoft.com/en-us/library/aa394372(VS.85).aspx
Get-WmiObject -class "Win32_Process" -namespace "root\cimv2" -ComputerName $server -Filter "name = 'notepad.exe'" | % { $_.terminate() }
Get-WmiObject -class "Win32_Process" -namespace "root\cimv2" -ComputerName $server -Filter "HandleCount > 1" | % { $_.name }
([WMICLASS]"\\$server\ROOT\CIMV2:win32_process").Create("notepad")
# Create remote process 
$path = "\\$server\root\cimv2:Win32_Process"
$ProcObj = new-object System.Management.ManagementClass $path
$p = $ProcObj.create('notepad.exe')
$return = $p.ReturnValue
$p.processid

# Services
# List and stop/start remote services using .Net System.ServiceProcess.ServiceController
$all_services = [System.ServiceProcess.ServiceController]::GetServices($server)
foreach ($service in $all_services) {
			if ($service.ServiceName -eq $service1)	{
				if ($service.Status -eq 'Running')	{
				(new-Object System.ServiceProcess.ServiceController($service1,$server)).Stop()
				(new-Object System.ServiceProcess.ServiceController($service1,$server)).WaitForStatus('Stopped',(new-timespan -seconds 5))
			} elseif ($service.Status -eq 'Stopped')	{
				Write-Host "Step #1) Auto: $service1 already stopped"
			}
		} 
}

# Running a process and capturing non-structured data output
$output = (Invoke-Expression "cacls c:\boot.ini"

[USING WMI TO GET DATA]
get-wmiobject win32_logicaldisk -filter "drivetype=3"  -computername blah| select-object deviceid, freespace,size


[PIPELINE OUTPUT]
# calculated properties using select-object .   Can be used to retrieve multipe properties from multipe pipeline members
get-vmhost dcvmhprd105.us.costar.local | get-vm | % { write-host $_.Name`|$_.Host.Name}

H:\>Get-VM dcadmin6 | Get-HardDisk | ft CapacityKB, @{n="myVMName" ;e={$_.parent.name} } ,FileName -autosize

CapacityKB myVMName Filename                                         
---------- -------- --------                                         
  26214400 dcadmin6 [ESX-USDC-PRDT2-1-VOL-1] dcadmin6/dcadmin6.vmdk  
  20971520 dcadmin6 [ESX-USDC-PRDT2-1-VOL-1] dcadmin6/dcadmin6_1.vmdk

[REGISTRY]
# Open remote registry and create a key/value
$reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $MachineName)
$regKey= $reg.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\Alerter",'true' )
$regKey.GetValueNames()
$regKey.SetValue('myval1','1','Dword')

[EVENTLOG]
$strcomputer = Read-Host "Please Enter the Server Name"
$source = Read-Host "Please Enter the Event Source"
$Evelog = new-object system.diagnostics.eventlog("$source", "$strComputer")
$Evelog.entries |Where {$_.Source -eq "Kerberos"}|format-table Index,Timegenerated, EventID, Message, Username


[POWERSHELL EXECUTION POLICY]
Set-ExecutionPolicy RemoteSigned	#All local scripts are allowed to run, but scripts downloaded from the Internet (e.g., received by email,
									# downloaded from Web sites) are required to have a signature from a trusted third party
Set-ExecutionPolicy Unrestricted 	# All scripts are allowed to run.


[DATES AND TIMES]
# http://msdn.microsoft.com/en-us/library/system.datetime_members(VS.80).aspx
[datetime]::Now

# Display date/time or both
Get-Date -displayhint [Date|DateTime|Time]

# Date arithmetic
(Get-Date).AddHours(-24)		# 1 day ago


# Thee New-TimeSpan cmdlet provides a way to do date arithmetic within Windows PowerShell. For example, this command tells you the number of days between today’s date and New Year’s Eve 2006
New-TimeSpan $(Get-Date) $(Get-Date –month 12 -day 31 -year 2006)

[FILES AND DIRECTORIES]
# Create a temporary file
$tmp = [System.IO.Path]::GetTempFileName()
$tmp
Remove-Item $tmp

# use measure-object to find size of directory

# read a file
get-content c:\temp\file.txt

# read a file with a filter
$all_log_entries = Get-Content $log | Where-Object -FilterScript {$_ -like "*system-notification-00257*" }

# fast reading of large files
use get-content with -ReadCount 0


[WEB SITES]
cls
$src = 'http://www.opm.gov/status/'
# $dst = 'c:\dev\example.html'
$useragent = 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2;)'
$Encoding = "Default"
$wc = New-Object system.Net.WebClient
$wc.Headers.Add("user-agent",$useragent)
$wc.Encoding = [System.Text.Encoding]::$Encoding
# splits on newlines
$str = $wc.DownloadString($src).Split("`n")
if ($str -match 'Federal agencies in the Washington, DC, area are <strong>OPEN</strong>') {
	Write-Host "agencies are open..."
} else	{
	Write-Host "agencies may not be open today"
}

[EMAIL]
param(
    [string[]] $to = $(throw "Please specify the destination mail address"),
    [string] $subject = "<No Subject>",
    [string] $body = $(throw "Please specify the message content"),
    [string] $smtpHost = $(throw "Please specify a mail server."),
    [string] $from = "$($env:UserName)@example.com"
  )

## Create the mail message
$email = New-Object System.Net.Mail.MailMessage

## Populate its fields
foreach($mailTo in $to)
{
    $email.To.Add($mailTo)
}

$email.From = $from
$email.Subject = $subject
$email.Body = $body

## Send the mail
$client = New-Object System.Net.Mail.SmtpClient $smtpHost
$client.UseDefaultCredentials = $true
$client.Send($email)

[PARAMETERS & FUNCTIONS]
#parameter 
# comments are ok, but param() must be first executable line in script
# call with .\example.ps1 -mytext a -mynum 1 -verbose
param (	[string] $mytext = $(throw 'error: specify -mytext'), [int] $mynum, [switch] $verbose )
Write- (Host "$mytext $mynum"

#function
param (	[string] $mytext = $(throw "Please specify a parameter") )
# functions need to be defined before they are called
function make-upper ([string] $mytext)	{
	 $mytext.ToUpper()
	 Get-Date
}
$r = make-upper $mytext
$myupper = $r[0] 
$mydate = $r[1]


# How to pass an array to a function
	function find_files ([array]$fileFilters)	{}
	$array = @('a','b')
	find_files @($array)


# function accessing pipeline input
cls
function list_name  {
	begin	{
		$count = 0;
		Write-Host "getting ready to process all pipeline input.."
	}
	process	{
		write-host "`t$($_.name) $($_.length)"
		$count++
	}
	end {
		"done processing pipeline input..."
	}
}
gci C:\temp\sync_on_arrival | list_name

[ARRAYS AND HASHES]
# How to ensure that the results of a command are stored in an array.
#   Otherwise, $collection may be null or contain a non array value
$collection = @(YourCommandHere)
($collection.Count)		# check size

# ARRAY: adding elements to a psh array list is expensive, use .Net instead.
$array = New-Object System.Collections.ArrayList
[void]$array.Add(1)
[void]$array.Add(2)
[void]$array.Add(3)
$array
[Void]$array.Remove(2)
$array

# How to create array without quotes?
	$ips = "192.168.27.152
		192.168.27.153".split("`n")
	foreach ($ip in $ips} { 
		$ip = $ip.Trim()
	}

# HASH: populating and sorting
$hash = @{ 'color1' = 'red'; 'color2' = 'blue' }
$hash.Add('color3','purple')
$hash["color3"]
-or-
$hash.Get_Item("color3")

# Search
$states.ContainsKey("Oregon")

# Itterate
$hash.Keys | % {
	"Key $_ : $($hash.$_)"
}
-or
foreach ($key in $hash.GetEnumerator() )	{
	$key.Value
	$key.Name



# sort on name (or value)
foreach ( $item in $hash.GetEnumerator() | sort name ) {
	$item.value
}

# Here string
$x = @"
"this is in quotes" and this is not!  Everything I add is interpreted literally & / | !
"@

[BUILT IN VARIABLES, VARIABLE SCOPE]
dir variable:*preference*

# scope
# to access or create a global variable within a function:
$script:logger_array = New-Object System.Collections.ArrayList
$global:logger_array = New-Object System.Collections.ArrayList

[INPUT AND INTERACTION]
# VERBOSITY: call with .\script.sp1 -verbose
# dir variable:*preference*
param ( [switch] $verbose )
if($Verbose) {
	$VerbosePreference = "continue"
	$p=$host.privatedata
	$p.VerboseBackgroundColor='Black'
	$p.VerboseForegroundColor='Gray'
}
Write-Verbose "this is verbose"
Write-Host "this is normal"

# USER INPUT
$directory = Read-Host "Enter a directory name..."
# read a keypress from the user, this must be run in a console
Write-Host "yes or no?"
$answer = [Console]::Readkey($true)
$answer

# Converting a password entered with read-host to readable text
$password = Read-Host "Enter a password..." -AsSecureString
$strSecurePass = Read-Host "Enter a password for your account...`n" -AsSecureString
$strBasicString = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($strSecurePass)
$strPassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($strBasicString)

[FORMATTING]
http://mspowershell.blogspot.com/2007/08/formatting-through-f-parameter.html

"{0,-8:P1}" -f 1.75
# The above format can be explained as:
"{argument index[,alignment][:formatString zeros]}"

##### Argument Index
"{0,-8}{1,-5}" -f "John", "Doe"		#John    Doe
"{0,8}{1,10}" -f "Albert", "Smith"	#  Albert     Smith

##### C - Currency, the number represents the number of trailing zeroes
"{0:C2}" -f 25000        #$25,000.00
"{0:C2}" -f -25000        #($25,000.00)

##### D - Decimal, the number represents the number of leading zeroes
"{0:D5}" -f 25        #"00025"
"{0:D5}" -f -25       #"-00025"

##### E - Exponential, the number represents the number of trailing zeroes
"{0:E5}" -f 25        #"2.50000E+E001"
"{0:E5}" -f -25        #"-2.50000E+E001"

##### N - Number, the number represents the number of trailing zeroes
"{0:N2}" -f 25        #"25.00"
"{0:N2}" -f -25        #"-25.00"

##### P - Percentage, the number represents the number of leading zeroes
"{0:P0}" -f .25        #25 %
"{0:P0}" -f -.25       #-25 %

##### X - Hexadecimal, the number represents the number of leading zeroes
"{0:X5}" -f 25        # "00019"
"{0:X5}" -f -25        # "FFFFFFE7"

#Rounding numbers
$a = [math]::round(45.987654321, 2)		# 45.99
-OR-
4.123 -as [int]
4.51 -as [int]

[VMWARE]

# accessing the ServiceContent construct
$ServiceInstance = Get-View ServiceInstance
$LicenseMan = Get-View $ServiceInstance.Content.LicenseManager

# Add the VMware VI Toolkit functionality
$VMCore = Get-PSSnapin VMware.VimAutomation.Core -EA 0
if ( -not $VMCore ) { Add-PSSnapin VMware.VimAutomation.Core };

# Load VI Toolkit env
C:\Program Files\VMware\Infrastructure\VIToolkitForWindows\Scripts\Initialize-VIToolkitEnviront.ps1
	# the stuff below should fix any errors relating to %APPDATA%\VMware\credstore errors
if (! (Test-Path [string]$env:APPDATA) ) {$env:APPDATA = $env:USERPROFILE + "\Application Data"} 
$USER = $env:username

# VIObjectByVIView - converts from managed object to Impl (simple object)

Possible get-view -ViewType values:
	ComputeResource, ClusterComputeResource, Datacenter, Datastore, Network, 
	DistributedVirtualPortgroup, DistributedVirtualSwitch, Folder, HostSystem, 
	ResourcePool, VirtualApp, VirtualMachine, VmwareDistributedVirtualSwitch

# Really fast access to managed objects
# takes 1.5 seconds
measure-command { get-view  -ViewType VirtualMachine -Filter @{"Name" = "dcadmin6"} | Get-VIObjectByVIView }
measure-command { Get-View -ViewType "VirtualMachine" }
Get-View -ViewType "HostSystem" -Property Name
Get-View -ViewType "ClusterComputeResource" -Property Name  | select Name
measure-command { Get-View -ViewType "ClusterComputeResource" -Filter @{"Name" = "Dev&Tst-Intel"} | VIObjectByVIView  | get-vm }

Get-View -ViewType "VirtualMachine" `
    -filter @{
        "Guest.GuestFamily"="windowsGuest";
        "Guest.ToolsStatus"="ToolsOld";
        "Guest.GuestState"="running"
    }

# this one has multiple properteis
measure-command {Get-View  -ViewType VirtualMachine -property Name,Config.Hardware | ForEach-Object {
	Write-host  $_.Name $_.Config.Hardware.memoryMB $_.Config.Hardware.numCPU }
	} | select  TotalSeconds
	

# Super fast object access with new-viproperty
>> Takes 12.5 seconds, TOO SLOOOOW
	measure-command { $vmCluster | Get-VM | Get-View | % {$_.guest.toolsversion} }
	
>> Takes .9 seconds, WOW!
	# Using the new-viproperty cmdlet	
	New-VIProperty -Name toolsVersion -Objecttype VirtualMachine -ValueFromExtensionProperty 'guest.toolsversion'
	measure-command { $vmCluster | get-vm | select name,toolsversion }

	
	
	
# PowerCli get-snapshot, new-snapshot way too slow (100 seconds)
# this takes < 1 second
get-view -ViewType virtualmachine -property snapshot -Filter @{"Snapshot"="VMware.Vim.VirtualMachineSnapshotInfo"; "Name"="dcsqlprd115"}

	
# access .net objects
$vm = get-view (get-vm vmtst1).id
or
$vm = get-vm vmtst1 | get-view
foreach ($v in $vm) { $v.config.files.vmPathName}
#Create a new object whose job it is to help configure some advanced properties of a VM
$vmConfigSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
# Create another new object which deals specifically with boot options, and assign it to the bootoptions property of our VM configurator object.
$vmConfigSpec.bootoptions = New-Object VMware.Vim.virtualmachinebootoptions
$vmConfigSpec.bootoptions.bootdelay = "2"
$vm.ReconfigVM($vmConfigSpec); 

# Getting log data from hosts
Get-LogType -VMHost dcvmhprd130.us.costar.local

$messages = get-log -VMHost dcvmhprd130.us.costar.local -Key 'messages'
$messages.Entries | where { $_ -notlike "*info*" }


[REGEX]
$a = 'DCSQLTST250\SHWTSTPROCESS,1604'
$null = $a -match '( (\w+)|(\w+\\\w+) )'
$matches[1]

# Matching using System.Text.RegularExpressions.Regex
$b = 'one two 3'
$pattern = '(\w+\s)(\w+\s)(\d+)'
$regex = New-Object System.Text.RegularExpressions.Regex ($pattern)
# RegexOptions.Compiled
$match = $regex.Match($a)
$one = $match.Groups[1].value
$two = $match.Groups[2].value
$three = $match.Groups[3].value




[ERROR HANDLING]
# http://blogs.msdn.com/monad/archive/2005/11/15/493102.aspx
$error.clear()
$WarningPreference = "SilentlyContinue"
$ErrorActionPreference = "SilentlyContinue"
$res = Get-Content c:\blah.txt
if ($error[0])	{
    write-host "failed"
} else	{
    write-host "OK"
}
$error.clear()

[POWERSHELL Drive & registry Mapping]
New-PSDrive -name X -psprovider FileSystem -root c:\scripts 
New-PSDrive -name Y -psprovider Registry -root HKCU:\Software\Microsoft\Windows\CurrentVersion


[Networking and TCP/IP]
# Ping a host
$p = Get-WmiObject -Class Win32_PingStatus -Filter "Address='www.google.com' and BufferSize=32 and Timeout=1000" -ComputerName .
# http://msdn.microsoft.com/en-us/library/aa394350%28VS.85%29.aspx


if ($p.StatusCode -ne 0)	{
	$ping_result = 'FAIL' + $($p.StatusCode)
} else {
	$ping_result = 'PASS'
}
write-host "$ping_result|$($p.IPV4Address.IPAddressToString)|$($p.Address)|$($p.responsetime)ms"

[POWERSHELL CUSTOM OBJECTS]
$allObj = @()
$obj = "" | Select-Object Col1,Col2
$obj.Col1 = "a"
$allObj += $obj
$obj.Col1 = "c"
$allObj

[SCHEDULING A POWERSHELL SCRIPT WITH TASK SCHEDULER]
C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -command "& 'c:\dir\myscript.ps1' "

with PowerCli and Task Scheduler : Includes command line parameters to the script
C:\WINDOWS\system32\windowspowershell\v1.0\powershell.exe -psc "C:\Program Files\VMware\Infrastructure\vSphere PowerCLI\vim.psc1" "& 'C:\scripts\vmSnapMonitor\Generate-VMSnapshotsReport.ps1' "  -vCenterServer dcappprd420 -smtpto bconrad@costar.com

# Bulletproof command line arguments, escapes entire string:
# don't forget the final "
POWERSHELL.EXE -command "& 'kiwiPS1Logger.ps1'  \"%MsgDate\"  \"%MsgTime\"  \"%MsgFacility\"  \"%MsgLevel\"  \"%MsgHost\"  \"%MsgText\" "

[IIS & Powershell]

# Determine which snapin to load
IIS 7.0 uses Add-PSSnapIn WebAdministration, IIS 7.5 uses Import-Module WebAdministration:

$iisVersion = Get-ItemProperty "HKLM:\software\microsoft\InetStp";
if ($iisVersion.MajorVersion -eq 7)
{
    if ($iisVersion.MinorVersion -ge 5)
    {
        Import-Module WebAdministration;
    }           
    else
    {
        if (-not (Get-PSSnapIn | Where {$_.Name -eq "WebAdministration";})) {
            Add-PSSnapIn WebAdministration;
        }
    }
}

