
				
#REQUIRES -Version 2.0


#
# Define global variables here
#
Set-StrictMode -version 2
$ErrorActionPreference = "Stop"

function Test-WMI
{
	<#
	.SYNOPSIS
	Tests to make sure we can connect to a remote server using WMI
	.DESCRIPTION
	Describe the function in more detail
	.EXAMPLE
	Give an example of how to use it
	.EXAMPLE
	Give another example of how to use it
	.PARAMETER computername
	The computer name to query. Just one.
	.PARAMETER logname
	The name of a file to write failed computer names to. Defaults to errors.txt.
	#>
	[CmdletBinding(
				   SupportsShouldProcess = $true,
				   ConfirmImpact = "High"
	)]
	
	param
	(
		[parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = 'What computer name would you like to target?')]
		[string[]]$computer
	)
	
	begin
	{
		
	}
	
	process
	{
		
		$wmiOs = Get-WmiObject -Class Win32_OperatingSystem -Computer $computer
		
		try
		{
			if ($wmiOs.Caption)
			{
				Write-Verbose "Successfully connected to $computer using WMI ($($wmiOs.Caption))"
			}
			
		}
		catch
		{
			# Write-Warning "Test-WMI: Unable to connect to $computer using WMI"
			return
		}
	}
	
	End
	{
		
	}
}

function Get-NetworkAdapterForDnsUpdate
{
  <#
  .SYNOPSIS
  Find a network adapter that has a default gateway
  .DESCRIPTION
  Describe the function in more detail
  .EXAMPLE
  Give an example of how to use it
  .EXAMPLE
  Give another example of how to use it
  .PARAMETER computername
  The computer name to query. Just one.
  .PARAMETER logname
  The name of a file to write failed computer names to. Defaults to errors.txt.
  #>
	[CmdletBinding(
				   SupportsShouldProcess = $true,
				   ConfirmImpact = "High"
	)]
	
	param
	(
		[parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = 'What computer name would you like to target?')]
		[string[]]$computer
	)
	
	begin
	{
		
	}
	
	process
	{
		
		try
		{
			Test-WMI -computer $computer
		}
		catch
		{
			Write-Warning "Unable to connect to $computer using WMI"
			return
		}
		
		$wmiNetworkAdapterConfiguration = Get-WmiObject -Class Win32_NetworkAdapterConfiguration -Computer $computer
		foreach ($networkAdapter in $wmiNetworkAdapterConfiguration)
		{
			try
			{
				if ($networkAdapter.DefaultIPGateway[0])
				{
					Write-Output $networkAdapter
				}
			}
			catch
			{
				
			}
		}
		
	}
	
	End
	{
		
	}
}

function Set-DNSServersOnNic
{
  <#
  .SYNOPSIS
  This function will set the DNS servers on the server nic
  .DESCRIPTION
  Describe the function in more detail
  .EXAMPLE
  Give an example of how to use it
  .EXAMPLE
  Give another example of how to use it
  .PARAMETER computername
  The computer name to query. Just one.
  .PARAMETER logname
  The name of a file to write failed computer names to. Defaults to errors.txt.
  #>
	[CmdletBinding(
				   SupportsShouldProcess = $true,
				   ConfirmImpact = "High"
	)]
	
	param
	(
		[parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
		[string]$computer,
		# I can't figure out how to specify the typename for this variable, want to do something like:
		#  System.Management.ManagementObject#root\cimv2\Win32_NetworkAdapterConfiguration
#		[parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
#		$wmiNic,
		[parameter(Mandatory = $true, ValueFromPipeline = $false, ValueFromPipelineByPropertyName = $false)]
		[string]$site,
		[parameter(Mandatory = $true, ValueFromPipeline = $false, ValueFromPipelineByPropertyName = $false)]
		[string]$zone
	
	)
	
	begin
	{
		
		$dnsServers = @{
			'Reston' = @{
				'int' = @("172.16.235.70", "172.17.132.64", "172.16.48.20")
				'dmz' = @("172.16.235.35", "172.17.132.50", "65.210.23.177")
			}
			'LAX' = @{
				'int' = @("172.16.144.17", "172.16.144.19", "172.16.3.136")
				'dmz' = @("204.253.48.161", "204.253.48.162", "172.16.235.35")
			}
			'Vienna' = @{
				'int' = @("172.16.48.20", "172.16.48.23", "172.16.3.136")
				'dmz' = @("65.210.23.177", "65.210.23.184", "172.16.235.35")
			}
		}
		
		
	}
	
	process
	{
		$wmiNic = Get-NetworkAdapterForDnsUpdate -computer $computer
		try
		{
			$result = $wmiNic.setDNSServerSearchOrder($dnsServers.Item($site).$zone)
			$newWmiNic = Get-NetworkAdapterForDnsUpdate -computer $computer
			$obj = "" | Select-Object Computername, ReturnValue, DNSServerSearchOrder
			$newDnsSearchOrder = ""
			foreach ($dnsServer in $newWmiNic.DNSServerSearchOrder)
			{
				$newDnsSearchOrder += $dnsServer+","
			}
			$obj.Computername = $computer
			$obj.ReturnValue = $result.returnvalue
			$obj.DNSServerSearchOrder = $newDnsSearchOrder
			Write-Output $obj
		}
		catch
		{
			$obj = "" | Select-Object Computername, ReturnValue, DNSServerSearchOrder
			$obj.Computername = $computer
			$obj.ReturnValue = 'fail'
			Write-Output $obj
		}
		
	}
	
	End
	{
		
	}
}

function Get-DNSServersOnNic
{
  <#
  .SYNOPSIS
  This function will get the DNS servers on the server nic
  .DESCRIPTION
  Describe the function in more detail
  .EXAMPLE
  Give an example of how to use it
  .EXAMPLE
  Give another example of how to use it
  .PARAMETER computername
  The computer name to query. Just one.
  .PARAMETER logname
  The name of a file to write failed computer names to. Defaults to errors.txt.
  #>
	[CmdletBinding(
				   SupportsShouldProcess = $true,
				   ConfirmImpact = "High"
	)]
	
	param
	(
		[parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
		[string]$computer
		
	)
	
	begin
	{
		
		
	}
	
	process
	{
		try
		{
			$newWmiNic = Get-NetworkAdapterForDnsUpdate -computer $computer
			$obj = "" | Select-Object Computername, DNSServerSearchOrder
			$newDnsSearchOrder = ""
			foreach ($dnsServer in $newWmiNic.DNSServerSearchOrder)
			{
				$newDnsSearchOrder += $dnsServer + ","
			}
			$obj.Computername = $computer
			$obj.DNSServerSearchOrder = $newDnsSearchOrder
			Write-Output $obj
		}
		catch
		{
			$obj = "" | Select-Object Computername, DNSServerSearchOrder
			$obj.Computername = $computer
			$obj.DNSServerSearchOrder = 'fail'
			Write-Output $obj
		}
		
	}
	
	End
	{
		
	}
}

#
# Main Body
#
